programmer.lst - generated by MGTEK Assembler ASM11 V1.26 Build 144 for WIN32 (x86) - Fri Dec 05 13:45:13 2025

    1:                                 ; --- DEFINITIONS (Offsets from Base $1000) ---
    2:          =00001000              REGBAS  EQU     $1000       ; Register Base Address
    3:                                 
    4:          =00000000              PORTA   EQU     $00         ; Offset for Port A
    5:          =00000004              PORTB   EQU     $04         ; Offset for Port B
    6:          =00000003              PORTC   EQU     $03         ; Offset for Port C
    7:          =00000007              DDRC    EQU     $07         ; Offset for Data Direction C
    8:                                 
    9:          =0000002B              BAUD    EQU     $2B         ; SCI Baud Register
   10:          =0000002D              SCCR2   EQU     $2D         ; SCI Control Register 2
   11:          =0000002E              SCSR    EQU     $2E         ; SCI Status Register
   12:          =0000002F              SCDR    EQU     $2F         ; SCI Data Register
   13:                                 
   14:          =0000003C              HPRIO   EQU     $3C         ; Offset for HPRIO (Mode Select)
   15:                                 
   16:          =000000FF              STACK   EQU     $00FF       ; Top of Internal RAM
   17:                                 
   18:                                 ; programming constants
   19:          =00000019              MAX_RETRIES EQU 25          ; max number of retries for programming pulse
   20:          =00000010              VPROG_BIT EQU   %00010000   ; bit 4 for VPP control (PA4)
   21:          =00000020              CE_BIT    EQU   %00100000   ; bit 5 for chip enable (PA5)
   22:          =00000040              OE_BIT    EQU   %01000000   ; bit 6 for output enable (PA6)
   23:                                 
   24:                                 ; variable storage in RAM
   25:          =00000100              PULSE_COUNT EQU $0100       ; counter for programming pulses
   26:                                 
   27:          =00000000                      ORG     $0000       ; start of program in RAM
   28:                                 
   29:     0000                        START:
   30:     0000 8E 00FF                        LDS     #STACK
   31:                                 
   32:     0003 CE 1000                        LDX     #REGBAS
   33:                                 
   34:                                         ; force single chip mode (MDA=0) but keep boot ROM enabled (rboot=1)
   35:     0006 86 C0                          LDAA    #$C0        
   36:     0008 A7 3C                          STAA    HPRIO,X     ; write to $103C
   37:                                 
   38:                                         ; make sure Port C is set as input (it should default to this anyway)
   39:     000A 86 00                          LDAA    #$00        ; set Port C as input
   40:     000C A7 07                          STAA    DDRC,X      ; write to $1007
   41:                                 
   42:                                         ; set up the control pins for the EPROM
   43:                                         ; start with CE (bit 5) and OE (bit 6) set HIGH so they're inactive
   44:     000E A6 00                          LDAA    PORTA,X     
   45:     0010 8A 60                          ORAA    #%01100000  
   46:     0012 A7 00                          STAA    PORTA,X     
   47:                                 
   48:                                         ; set up serial communication (SCI)
   49:                                         ; configure for 9600 baud rate (based on 8MHz crystal / 2MHz E-clock)
   50:     0014 86 30                          LDAA    #$30        ; set the baud rate divisors: SCP1:0=11 (div 13), SCR2:0=000 (div 1)
   51:     0016 A7 2B                          STAA    BAUD,X
   52:     0018 86 0C                          LDAA    #$0C        ; turn on transmit and receive
   53:     001A A7 2D                          STAA    SCCR2,X
   54:                                 
   55:                                         ; ==================================================
   56:                                         ; IMPORTANT: Wait here for about 1 second!
   57:                                         ; This gives the Python script time to switch 
   58:                                         ; the computer's baud rate to 9600.
   59:                                         ; ==================================================
   60:     001C 9D 48                          JSR     LONG_DELAY
   61:                                         ; ==================================================
   62:                                 
   63:                                         ; set up our counters before we start reading
   64:     001E 4F                             CLRA                ; A will track which address we're reading (starts at 0)
   65:     001F C6 19                          LDAB    #25         ; B counts how many bytes left to read (25 total)
   66:                                 
   67:     0021                        READ_LOOP:
   68:                                         ; step 1: tell the EPROM which address we want to read from
   69:     0021 A7 04                          STAA    PORTB,X     
   70:                                 
   71:     0023 01                             NOP                 ; wait a moment for things to stabilize
   72:                                 
   73:                                         ; step 2: turn on the EPROM by pulling CE and OE low
   74:     0024 36                             PSHA                ; save our address for later
   75:     0025 A6 00                          LDAA    PORTA,X     
   76:     0027 84 9F                          ANDA    #%10011111  ; clear bits 5 and 6 to pull them low
   77:     0029 A7 00                          STAA    PORTA,X     
   78:     002B 32                             PULA                ; get our address back
   79:                                 
   80:     002C 01                             NOP                 ; give the EPROM time to put the data on the bus
   81:     002D 01                             NOP
   82:                                 
   83:                                         ; step 3: read the byte from the EPROM
   84:     002E 36                             PSHA                ; save our address first (we need A for the data)
   85:     002F A6 03                          LDAA    PORTC,X     ; read the data byte from Port C into A
   86:                                         
   87:                                         ; ==============================================
   88:                                         ; step 4: send what we just read to the computer
   89:                                         ; ==============================================
   90:     0031 9D 41                          JSR     SEND_SERIAL ; call subroutine to transmit the byte
   91:                                         ; ==============================================
   92:                                 
   93:     0033 32                             PULA                ; bring back our address counter
   94:                                 
   95:                                         ; step 5: turn off the EPROM by setting CE and OE back to high
   96:     0034 36                             PSHA
   97:     0035 A6 00                          LDAA    PORTA,X
   98:     0037 8A 60                          ORAA    #%01100000  
   99:     0039 A7 00                          STAA    PORTA,X
  100:     003B 32                             PULA
  101:                                 
  102:                                         ; step 6: move to the next byte
  103:     003C 4C                             INCA                ; go to next address
  104:     003D 5A                             DECB                ; one less byte to read
  105:     003E 26 E1                          BNE     READ_LOOP   ; keep going if we're not done yet
  106:                                 
  107:     0040 3F                             SWI                 ; all done! stop heredone! stop here
  108:                                 
  109:                                 ; subroutine to send whatever's in A out the serial port
  110:     0041                        SEND_SERIAL:
  111:     0041 1F 2E 80 FC                    BRCLR   SCSR,X #$80 SEND_SERIAL ; wait here until transmit buffer is empty (TDRE bit)
  112:     0045 A7 2F                          STAA    SCDR,X                  ; write our byte to the transmit register
  113:     0047 39                             RTS
  114:                                 
  115:                                 ; subroutine for a long delay (roughly 1 second)
  116:     0048                        LONG_DELAY:
  117:     0048 183C                           PSHY                ; save Y so we don't mess it up
  118:     004A 3C                             PSHX                ; save X too (important: we need X = $1000 later!)
  119:                                         
  120:     004B 18CE 0010                      LDY     #$0010      ; outer loop runs 16 times
  121:     004F                        DELAY_OUTER:
  122:     004F CE FFFF                        LDX     #$FFFF      ; inner loop runs 65535 times each
  123:     0052                        DELAY_INNER:
  124:     0052 09                             DEX
  125:     0053 26 FD                          BNE     DELAY_INNER ; keep counting down X until it hits zero
  126:     0055 1809                           DEY
  127:     0057 26 F6                          BNE     DELAY_OUTER ; keep going through Y until it hits zero too
  128:                                         
  129:     0059 38                             PULX                ; restore X back to $1000
  130:     005A 1838                           PULY                ; restore Y
  131:     005C 39                             RTS
  132:                                 
  133:                                 ; subroutine to program a single byte to the EPROM
  134:                                 ; assumes: data to program is in stack at 0,Y
  135:                                 ; assumes: address to program is in stack at 1,Y
  136:     005D                        PROGRAM_BYTE:
  137:     005D 86 01                          LDAA    #1              ; start with pulse count = 1
  138:     005F B7 0100                        STAA    PULSE_COUNT     ; store it
  139:                                 
  140:     0062                        PULSE_LOOP:
  141:                                         ; step 1: set data and address on the EPROM pins
  142:     0062 18A6 01                        LDAA    1,Y             ; load address from stack
  143:     0065 A7 04                          STAA    PORTB,X         ; put it on the address lines
  144:                                         
  145:                                         ; set Port C to output mode
  146:     0067 36                             PSHA
  147:     0068 86 FF                          LDAA    #$FF            ; configure all bits as output
  148:     006A A7 07                          STAA    DDRC,X
  149:     006C 32                             PULA
  150:                                         
  151:     006D 18A6 00                        LDAA    0,Y             ; load data from stack
  152:     0070 A7 03                          STAA    PORTC,X         ; put it on the data lines
  153:                                 
  154:                                         ; step 2: apply a 1ms programming pulse
  155:                                         ; turn on VPP, keep OE high, pull CE low
  156:     0072 A6 00                          LDAA    PORTA,X
  157:     0074 8A 10                          ORAA    #VPROG_BIT      ; turn on VPP (12.5V)
  158:     0076 8A 40                          ORAA    #OE_BIT         ; keep OE high (disable output)
  159:     0078 A7 00                          STAA    PORTA,X
  160:                                         
  161:                                         ; wait for VPP to stabilize (datasheet requires 2Âµs to 1ms setup time)
  162:     007A 01                             NOP
  163:     007B 01                             NOP
  164:     007C 01                             NOP
  165:     007D 01                             NOP
  166:                                         
  167:                                         ; now pull CE low to start the pulse
  168:     007E A6 00                          LDAA    PORTA,X
  169:     0080 84 DF                          ANDA    #%11011111      ; pull CE low (enable chip)
  170:     0082 A7 00                          STAA    PORTA,X
  171:                                         
  172:     0084 9D E2                          JSR     DELAY_1MS       ; wait for 1ms
  173:                                 
  174:                                         ; end the pulse by pulling CE high and turning off VPP
  175:     0086 A6 00                          LDAA    PORTA,X
  176:     0088 8A 20                          ORAA    #CE_BIT         ; pull CE high (disable chip)
  177:     008A 84 EF                          ANDA    #%11101111      ; turn off VPP (back to 5V)
  178:     008C A7 00                          STAA    PORTA,X
  179:                                 
  180:                                         ; step 3: verify the byte by reading it back
  181:                                         ; set Port C to input mode so we can read
  182:     008E 36                             PSHA
  183:     008F 86 00                          LDAA    #$00
  184:     0091 A7 07                          STAA    DDRC,X
  185:     0093 32                             PULA
  186:                                 
  187:                                         ; turn on read mode (CE low, OE low) now that VPP is off
  188:     0094 A6 00                          LDAA    PORTA,X
  189:     0096 84 9F                          ANDA    #%10011111      ; pull CE and OE low for reading
  190:     0098 A7 00                          STAA    PORTA,X
  191:                                         
  192:     009A 01                             NOP                     ; wait for data to appear
  193:                                         
  194:     009B A6 03                          LDAA    PORTC,X         ; read the data we just programmed
  195:     009D 18A1 00                        CMPA    0,Y             ; compare it with what we wanted
  196:     00A0 27 12                          BEQ     VERIFY_PASS     ; if they match, we're done with this byte!
  197:                                 
  198:                                         ; step 4: verify failed - we need to retry
  199:                                         ; reset the control pins to inactive
  200:     00A2 A6 00                          LDAA    PORTA,X
  201:     00A4 8A 60                          ORAA    #%01100000      ; pull CE and OE back high
  202:     00A6 A7 00                          STAA    PORTA,X
  203:                                 
  204:     00A8 7C 0100                        INC     PULSE_COUNT     ; try again (increment pulse count)
  205:     00AB B6 0100                        LDAA    PULSE_COUNT
  206:     00AE 81 19                          CMPA    #MAX_RETRIES    ; have we tried too many times?
  207:     00B0 2E 2F                          BGT     PROG_FAIL       ; if yes, the EPROM might be defective
  208:                                         
  209:     00B2 20 AE                          BRA     PULSE_LOOP      ; go back and try another 1ms pulse
  210:                                 
  211:     00B4                        VERIFY_PASS:
  212:                                         ; step 5: over-program with pulses equal to 3x total previous attempts
  213:                                         ; set Port C back to output and restore the data
  214:     00B4 86 FF                          LDAA    #$FF
  215:     00B6 A7 07                          STAA    DDRC,X
  216:     00B8 18A6 00                        LDAA    0,Y
  217:     00BB A7 03                          STAA    PORTC,X
  218:                                 
  219:                                         ; calculate over-program duration: PULSE_COUNT * 3ms
  220:     00BD F6 0100                        LDAB    PULSE_COUNT     ; get the number of pulses it took
  221:     00C0 86 03                          LDAA    #3              ; multiply by 3
  222:     00C2 3D                             MUL                     ; result in D (A:B)
  223:     00C3 37                             PSHB                    ; save loop count
  224:                                         
  225:     00C4                        OVER_PROG_LOOP:
  226:                                         ; turn on VPP and apply CE low for 1ms
  227:     00C4 A6 00                          LDAA    PORTA,X
  228:     00C6 8A 10                          ORAA    #VPROG_BIT      ; turn on VPP
  229:     00C8 8A 40                          ORAA    #OE_BIT         ; keep OE high
  230:     00CA 84 DF                          ANDA    #%11011111      ; CE low
  231:     00CC A7 00                          STAA    PORTA,X
  232:                                         
  233:     00CE 9D E2                          JSR     DELAY_1MS       ; 1ms pulse
  234:                                         
  235:                                         ; end pulse (CE high, but keep VPP on for now)
  236:     00D0 A6 00                          LDAA    PORTA,X
  237:     00D2 8A 20                          ORAA    #CE_BIT         ; CE high
  238:     00D4 A7 00                          STAA    PORTA,X
  239:                                         
  240:     00D6 5A                             DECB                    ; one less millisecond to go
  241:     00D7 26 EB                          BNE     OVER_PROG_LOOP  ; repeat for total duration
  242:                                         
  243:     00D9 33                             PULB                    ; clean up stack
  244:                                         
  245:                                         ; end over-program: turn off VPP
  246:     00DA A6 00                          LDAA    PORTA,X
  247:     00DC 84 EF                          ANDA    #%11101111      ; VPP low
  248:     00DE A7 00                          STAA    PORTA,X
  249:                                         
  250:     00E0 39                             RTS                     ; done! return to caller
  251:                                 
  252:     00E1                        PROG_FAIL:
  253:                                         ; byte could not be programmed after 25 retries
  254:     00E1 3F                             SWI                     ; stop and signal error
  255:                                 
  256:                                 ; subroutine for 1 millisecond delay
  257:     00E2                        DELAY_1MS:
  258:     00E2 183C                           PSHY
  259:     00E4 3C                             PSHX
  260:                                         
  261:     00E5 18CE 0004                      LDY     #$0004          ; approx. 1ms at 2MHz E-clock
  262:     00E9                        DELAY_1MS_OUTER:
  263:     00E9 CE FFFF                        LDX     #$FFFF
  264:     00EC                        DELAY_1MS_INNER:
  265:     00EC 09                             DEX
  266:     00ED 26 FD                          BNE     DELAY_1MS_INNER
  267:     00EF 1809                           DEY
  268:     00F1 26 F6                          BNE     DELAY_1MS_OUTER
  269:                                         
  270:     00F3 38                             PULX
  271:     00F4 1838                           PULY
  272:     00F6 39                             RTS
